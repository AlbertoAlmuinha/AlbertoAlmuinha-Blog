---
title: "Modelos Bayesianos Estructurales con Bayesmodels"
author: "Alberto Almui√±a"
date: '2021-06-22T01:13:14-05:00'
description: Introducci√≥n a modelos bayesianos estructurales con Bayesmodels y Bsts como Backend.
slug: bayesmodels-bsts-es
tags:
  - bayesmodels
  - Bayesian Structural Time Series
  - bsts
  - State Space Models
categories: 
  - Time Series
---

<img src="/img/bayesian-structural-bayesmodels.es_files/logo-bayesmodels.png" width="147" height="170" align="right"/>


‚ö†Ô∏è Atenci√≥n: Este post es una r√©plica del post [Fitting Bayesian structural time series with the bsts R package](https://www.unofficialgoogledatascience.com/2017/07/fitting-bayesian-structural-time-series.html) escrito por Steven L. Scott pero adaptado al paquete [bayesmodels](https://github.com/AlbertoAlmuinha/bayesmodels). Lo que haremos ser√° replicar los ejemplos de dicho post adaptados a este nuevo paquete.

## Introducci√≥n

El paquete __bayesmodels__ es un framework para modelos bayesianos soportado por tidymodels. Al igual que todo el universo tidymodels, la idea principal de estos paquetes es realizar una traducci√≥n sobre paquetes ya existentes para incorporar los algoritmos de los mismos con una sintaxis y definici√≥n que sea siempre coherente (mismo argumento en diferentes paquetes pasen a llamarse igual etc). Uno de los paquetes (entre otros muchos) que incorporta bayesmodels es __bsts__, m√°s en concreto el modelo bsts (Bayesian Structural Time Series). Los ejemplos que vamos a ver en este post son los siguientes:

- [X] Nowcasting: incluye descripciones de los modelos de tendencia lineal local y de estado estacional para predicciones a corto.

- [X] Previsi√≥n a largo plazo: describe una situaci√≥n en la que el nivel local y los modelos de tendencia lineal local ser√≠an inapropiados. Ofrece un modelo de tendencia lineal semilocal como alternativa.

## Nowcasting üî¨

Scott y Varian (2014, 2015) utilizaron modelos de series temporales estructurales para mostrar c√≥mo los datos de b√∫squeda de Google pueden utilizarse para mejorar las previsiones a corto plazo ("nowcasts") de las series temporales econ√≥micas. Los datos consisten en las solicitudes iniciales semanales de seguro de desempleo en EE.UU., seg√∫n lo informado por la Reserva Federal de EE.UU.. Como muchas estad√≠sticas oficiales, se publican con retraso y est√°n sujetas a revisi√≥n. Al final de la semana, la actividad econ√≥mica que determina estas cifras ha tenido lugar, pero las cifras oficiales no se publican hasta varios d√≠as despu√©s. Para las decisiones econ√≥micas basadas en estas cifras y otras similares, ser√≠a √∫til disponer de una previsi√≥n temprana de la cifra de la semana en curso al cierre de la misma. Por lo tanto, el resultado de este an√°lisis es realmente una "previsi√≥n" de los datos que ya han sucedido y no una "previsi√≥n" de los datos que suceder√°n en el futuro. Hay dos fuentes de informaci√≥n sobre el valor actual $y_{t}$ en la serie de reclamaciones iniciales: los valores pasados $y_{t}-\tau$ que describen el comportamiento de la serie temporal, y los predictores contempor√°neos $x_{t}$ procedentes de una fuente de datos que est√° correlacionada con $y_{t}$ , pero que est√° disponible sin el retraso que presenta $y_{t}$ . La estructura de la serie temporal muestra una tendencia evidente (en la que se aprecian las crisis financiera y de la vivienda de 2008-2009), as√≠ como un fuerte patr√≥n estacional anual. La fuente de datos externa explorada por Scott y Varian fueron los datos de b√∫squeda de Google trends, con consultas de b√∫squeda como "c√≥mo solicitar el desempleo" que tienen una relevancia evidente.

### Carga de librer√≠as üìö y visualizaci√≥n de datos üìä    

```{r, warning=FALSE, message=FALSE}
library(bayesmodels)
library(tidymodels)
library(timetk)
library(modeltime)

data(iclaims)

names(initial.claims)
```

Como vemos, tenemos un objeto de clase "zoo" con varias series de desempleo. Para trabajar con un formato tidy como el que emplea __bayesmodels__, debemos transformar nuestros datos al formato tabla. Para ello, una manera muy sencilla de conseguirlo es hacer uso de la funcionalidad que ofrece el paquete `timetk::tk_tbl()`:

```{r}
df <- timetk::tk_tbl(initial.claims)

df %>% plot_time_series(.date_var = index, 
                        .value = iclaimsNSA, 
                        .smooth = FALSE)
```

El siguiente paso ser√° especificar las componentes del estado, para ello haremos uso de las funciones del paquete `bsts` que bayesmodels ya carga por defecto:

```{r}
ss <- AddLocalLinearTrend(list(), df$iclaimsNSA)
ss <- AddSeasonal(ss, df$iclaimsNSA, nseasons = 52)
```

Una vez definimos el estado, construimos la definici√≥n del modelo de la siguiente manera (en __bayesmodels__ es obligatorio pasar siempre una variable de fecha aunque este no ser√° utilizara como variable regresora en el modelo).

```{r}
modelo <- bayesian_structural_reg() %>%
          set_engine("stan", state.specification = ss, niter = 1000) %>%
          fit(iclaimsNSA ~ index, data = df)
```

A continuaci√≥n, podemos visualizar la distribuci√≥n posterior del modelo:

```{r}
plot(modelo$fit$models$model_1)
```

Tambi√©n podemos visualizar los componentes que conforman el modelo. F√≠jate que el gr√°fico parece borroso porque muestra la distribuci√≥n posterior marginal en cada punto de tiempo.

```{r}
plot(modelo$fit$models$model_1, "components")
```

Ahora podemos predecir los tres meses siguientes, para ellos, haremos uso de **Modeltime**:

### Modeltime Workflow üíª

En primer lugar, generamos la tabla de Modeltime en la que almacenamos los modelos (en este caso s√≥lo tendremos uno, pero podr√≠an ser m√°s):

```{r}
(modeltime_tbl <- modeltime_table(modelo))
```

A continuaci√≥n, vamos a generar el dataset futuro para que se puedan llevar a cabo las predicciones. Para ello, haremos uso de la funci√≥n `timetk::future_frame()`. Extendemos el dataset en 12 observaciones porque al ser una periodicidad semanal asi obtendremos los tres meses deseados:

```{r}
df <- df %>% future_frame(.date_var = index, .length_out = 12, .bind_data = TRUE)

future_tbl <- df %>% dplyr::filter(is.na(iclaimsNSA))

prepared_tbl <- df %>% tidyr::drop_na()
```

Ahora es el turno de predecir...

```{r, warning=FALSE, message=FALSE}
modeltime_tbl %>%
  modeltime_forecast(
    new_data = future_tbl,
    actual_data = prepared_tbl
  ) %>%
  plot_modeltime_forecast()
```

Tambi√©n puedes llegar al mismo resultado haciendolo de la forma tradicional:

```{r}
predict(modelo$fit$models$model_1, h = 12) %>% plot(plot.original = 156)
```

Cu√°l es la desventaja de hacerlo de esta forma? Pues que para cada m√©todo tendr√≠as que aplicar su sintaxis espec√≠fica, sin embargo, con Modeltime siempre aplicas la misma sintaxis utilices el algoritmo que utilices.

## Previsi√≥n a largo plazo üî≠

La idea de este ejemplo es ver una comparativa entre las distintas opciones que existen para modelar la tendencia de una serie a trav√©s del backend __bsts__. La idea es comparar como var√≠a la varianza de dos modelos que utilizan `AddLocalLinearTrend` y `AddSemilocalLinearTrend`. Para ello, usaremos los datos del √≠ndice SP500 para Johnson & Johnson que descargaremos a trav√©s del paquete `tidyquant`:

```{r, warning=FALSE, message=FALSE}
library(tidyquant)

df <- tq_get("JNJ") %>% dplyr::select(date, close) %>% purrr::set_names(c("index", "value"))

df %>% plot_time_series(.date_var = index,
                        .value = value,
                        .smooth = FALSE,
                        .title = "Johnson & Johnson")
```

Preparamos el conjunto futuro al igual que hicimos en el ejemplo anterior:

```{r}
df <- df %>% future_frame(.date_var = index, .length_out = 360, .bind_data = TRUE)

future_tbl <- df %>% dplyr::filter(is.na(value))

prepared_tbl <- df %>% tidyr::drop_na()
```


Vamos a generar los dos modelos que comentamos, cada uno con una de las diferentes tendencias. Para una explicaci√≥n detallada de lo que representa cada una de las tendencias y qu√© relaci√≥n hay entre cada una de ellas y la varianza os recomiendo leer directamente el genial [art√≠culo](https://www.unofficialgoogledatascience.com/2017/07/fitting-bayesian-structural-time-series.html) del autor del paquete __bsts__ Steven L. Scott. El explica perfectamente todos estos conceptos y las diferencias entre ellos.

```{r}
ss1 <- AddLocalLinearTrend(list(), prepared_tbl$value)

modelo1 <- bayesian_structural_reg() %>%
           set_engine("stan", state.specification = ss1, niter = 1000) %>%
           fit(value ~ index, data = prepared_tbl)
```

Ahora generamos el segundo modelo:

```{r}
ss2 <- AddSemilocalLinearTrend(list(), prepared_tbl$value)
modelo2 <- bayesian_structural_reg() %>%
           set_engine("stan", state.specification = ss2, niter = 1000) %>%
           fit(value ~ index, data = prepared_tbl)
```

### Modeltime Workflow üíª

Generamos la tabla de modeltime en primer lugar:

```{r}
(modeltime_tbl <- modeltime_table(modelo1, modelo2))
```

Veamos las predicciones:

```{r, warning=FALSE, message=FALSE}
modeltime_tbl %>%
  modeltime_forecast(
    new_data = future_tbl,
    actual_data = prepared_tbl
  ) %>%
  plot_modeltime_forecast()
```

Para ver la comparaci√≥n de las varianzas, recurrimos a la funci√≥n `predict`: 

```{r}
predict(modelo1$fit$models$model_1, horizon = 360) %>% plot(., plot.original = 360, ylim = range(.))
```

```{r}
predict(modelo2$fit$models$model_1, horizon = 360) %>% plot(., plot.original = 360, ylim = range(.))
```

Las expectativas de previsi√≥n de los dos modelos son bastante similares, pero los errores de previsi√≥n del modelo de tendencia lineal local son inveros√≠milmente amplios, incluyendo una probabilidad peque√±a pero no nula de que el √≠ndice S&P 500 pueda cerrar cerca de cero en los pr√≥ximos 360 d√≠as. Las barras de error del modelo de tendencia lineal semilocal son mucho m√°s plausibles y se ajustan m√°s a la incertidumbre observada durante la vida de la serie hasta ahora.
                  
## Contacto ‚úâ

Alberto Almui√±a, [Linkedin](https://www.linkedin.com/in/alberto-almui%C3%B1a-b1176881/), [Twitter](https://twitter.com/AlmuinaAlberto), [Github](https://github.com/AlbertoAlmuinha), [Blog](https://albertoalmuinha.com/es/).
